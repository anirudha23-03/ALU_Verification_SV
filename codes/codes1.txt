`include "defines.sv"

module ALU_DESIGN /*#(parameter `DATA_WIDTH = 8, `CMD_WIDTH = 4)*/(INP_VALID,OPA,OPB,CIN,CLK,RST,CMD,CE,MODE,COUT,OFLOW,RES,G,E,L,ERR);
 
  input [`DATA_WIDTH-1:0] OPA,OPB;
  input CLK,RST,CE,MODE,CIN;
  input [`CMD_WIDTH-1:0] CMD;
  input [1:0] INP_VALID;
  output reg [`DATA_WIDTH+1:0] RES = 9'bz;
  output reg COUT = 1'bz;
  output reg OFLOW = 1'bz;
  output reg G = 1'bz;
  output reg E = 1'bz;
  output reg L = 1'bz;
  output reg ERR = 1'bz;

 
  reg [`DATA_WIDTH-1:0] OPA_1, OPB_1;
  reg [`DATA_WIDTH-1:0] oprd1, oprd2;
  reg [3:0] CMD_tmp;
  reg [`DATA_WIDTH-1:0] AU_out_tmp1,AU_out_tmp2 ;
  // Added timer and state tracking
  reg [4:0] wait_counter;
  reg oprd1_valid, oprd2_valid;
  
  always @ (posedge CLK) begin
      if(RST) begin
        oprd1<=0;
        oprd2<=0;
        CMD_tmp<=0;
        wait_counter<=0;
        oprd1_valid<=0;
        oprd2_valid<=0;
      end
      else if (INP_VALID==2'b01)  begin    
        oprd1<=OPA;
        CMD_tmp<=CMD;
        oprd1_valid<=1;
        wait_counter<=0;
        // Set error if second operand comes after 16 cycles
        if(oprd2_valid && wait_counter >= 16) begin
          ERR <= 1'b1;
        end
      end
      else if (INP_VALID==2'b10)  begin    
        oprd2<=OPB;
        CMD_tmp<=CMD;
        oprd2_valid<=1;
        wait_counter<=0;
        // Set error if second operand comes after 16 cycles
        if(oprd1_valid && wait_counter >= 16) begin
          ERR <= 1'b1;
        end
      end
      else if (INP_VALID==2'b11)  begin    
        oprd1<=OPA;
        oprd2<=OPB;
        CMD_tmp<=CMD;
        oprd1_valid<=1;
        oprd2_valid<=1;
        wait_counter<=0;
      end
      else begin    
        // Increment wait counter if only one operand is valid
        if((oprd1_valid && !oprd2_valid) || (!oprd1_valid && oprd2_valid)) begin
          if(wait_counter < 16) begin
            wait_counter <= wait_counter + 1;
          end else begin
            // Keep operands but stop incrementing counter after 16 cycles
            wait_counter <= 16;
          end
        end
      end
    end
 
 
    always@(posedge CLK)
      begin
       if(CE)                   
        begin
         if(RST)                
          begin
            RES=9'bzzzzzzzzz;
            COUT=1'bz;
            OFLOW=1'bz;
            G=1'bz;
            E=1'bz;
            L=1'bz;
            ERR=1'bz;
            AU_out_tmp1=0;
            AU_out_tmp2=0;
          end
         else if(MODE && oprd1_valid && oprd2_valid)          
         begin
           RES=9'bzzzzzzzzz;
           COUT=1'bz;
           OFLOW=1'bz;
           G=1'bz;
           E=1'bz;
           L=1'bz;
           ERR=1'bz;
          case(CMD_tmp)             
    4'b0000:                   begin             
              RES=oprd1+oprd2;
              COUT=RES[8]?1:0;
            end
      4'b0001 :                begin
             OFLOW=(oprd1<oprd2)?1:0;
             RES=oprd1-oprd2;
            end
           4'h2:            
            begin
             RES=oprd1+oprd2+CIN;
             COUT=RES[8]?1:0;
            end
           4'b0011:             
           begin
            OFLOW=(oprd1<oprd2)?1:0;
            RES=oprd1-oprd2-CIN;
           end
           4'b0100:RES=oprd1;    
           4'b0101:RES=oprd1-1;    
           4'b0110:RES=oprd2-1;    
           4'b0111:RES=oprd2+1;    
           4'b1000:              
           begin
            RES=9'bzzzzzzzzz;
            if(oprd1==oprd2)
             begin
               E=1'b1;
               G=1'bz;
               L=1'bz;
             end
            else if(oprd1>oprd2)
             begin
               E=1'bz;
               G=1'b1;
               L=1'bz;
             end
            else 
             begin
               E=1'bz;
               G=1'bz;
               L=1'b1;
             end
           end
	   4'b1001: begin   
                    AU_out_tmp1 <= oprd1 + 1;
                    AU_out_tmp2 <= oprd2 + 1;
                    RES <=AU_out_tmp1 * AU_out_tmp2;
                  end
           4'b1010: begin   
                    AU_out_tmp1 <= oprd1 << 1;
                    AU_out_tmp2 <= oprd2;
                    RES <=AU_out_tmp1 - AU_out_tmp2; 
                  end
 
           default:   
            begin
            RES=9'bzzzzzzzzz;
            COUT=1'bz;
            OFLOW=1'bz;
            G=1'bz;
            E=1'bz;
            L=1'bz;
            ERR=1'bz;
           end
          endcase
         end
        else if(!MODE && oprd1_valid && oprd2_valid)          
        begin 
           RES=9'bzzzzzzzzz;
           COUT=1'bz;
           OFLOW=1'bz;
           G=1'bz;
           E=1'bz;
           L=1'bz;
           ERR=1'bz;
           case(CMD_tmp)    
             4'b0000:RES={1'b0,oprd1&oprd2};     
             4'b0001:RES={1'b0,~(oprd1&oprd2)};  
             4'b0010:RES={1'b0,oprd1&&oprd2};     
             4'b0011:RES={1'b0,~(oprd1|oprd2)};  
             4'b0100:RES={1'b0,oprd1^oprd2};     
             4'b0101:RES={1'b0,~(oprd1^oprd2)};  
             4'b0110:RES={1'b0,~oprd1};        
             4'b0111:RES={1'b0,~oprd2};        
             4'b1000:RES={1'b0,oprd1};      
             4'b1001:RES={1'b0,oprd1<<1};      
             4'b1010:RES={1'b0,oprd2<<1};      
             4'b1011:RES={1'b0,oprd2<<1};     
             4'b1100:                        
             begin
               if(oprd2[0])
                 OPA_1 = {oprd1[6:0], oprd1[7]};
               else
                 OPA_1 = oprd1;
               if(oprd2[1])
                 OPB_1 =  {OPA_1[5:0], OPA_1[7:6]}; 
               else
                 OPB_1= OPA_1;
               if(oprd2[2])
                 RES =  {OPB_1[3:0], OPB_1[7:4]} ;
               else
                 RES = OPB_1;
               if(oprd2[4] | oprd2[5] | oprd2[6] | oprd2[7])
                 ERR=1'b1;
             end
             4'b1101:                        
             begin
               if(oprd2[0])
                 OPA_1 = {oprd1[0], oprd1[7:1]};
               else
                 OPA_1 = oprd1;
               if(oprd2[1])
                 OPB_1 =  {OPA_1[1:0], OPA_1[7:2]}; 
               else
                 OPB_1= OPA_1;
               if(oprd2[2])
                 RES =  {OPB_1[3:0], OPB_1[7:4]} ;
               else
                 RES = OPB_1;
               if(oprd2[4] | oprd2[5] | oprd2[6] | oprd2[7])
                 ERR=1'b0;
             end
             default:   
               begin
               RES=9'bzzzzzzzzz;
               COUT=1'bz;
               OFLOW=1'bz;
               G=1'bz;
               E=1'bz;
               L=1'bz;
               ERR=1'bz;
               end
          endcase
     end
    end
   end
endmodule
//`include "defines.sv"
//`include "alu_transaction.sv"

class alu_generator;
	alu_transaction blueprint;
	mailbox #(alu_transaction)mbx_gd; //mailbox for generator to driver
	
	function new(mailbox#(alu_transaction)mbx_gd);
		this.mbx_gd = mbx_gd;
		blueprint = new();
	endfunction

	//random stimulus generation
	task start();
		for(int i = 0; i < `NO_OF_TRANS; i++) 
			begin
				void'(blueprint.randomize());
				mbx_gd.put(blueprint.copy());
				$display("GENERATOR Randomized transaction: %d\n",i);
				$display("[%0t] CE = %0d, INP_VALID = %0d, MODE = %0d, CMD = %0d, OPA = %0d, OPB = %0d, CIN = %0d\n",$time,blueprint.CE,blueprint.INP_VALID,blueprint.MODE,blueprint.CMD, blueprint.OPA,blueprint.OPB,blueprint.CIN);
			end
		$display("******************** GENERATOR COMPLETED ********************\n");
	endtask
endclass


//`include "defines.sv"
//`include "alu_transaction.sv"

class alu_driver;
	alu_transaction drv_trans;
	mailbox #(alu_transaction)mbx_gd; //genetator to driver
	mailbox #(alu_transaction)mbx_dr; //driver to reference model
	//virtual interface with driver modport and it's instance
	virtual alu_if.DRV vif;

	//functional coverage for inputs
	covergroup drv_cg;
		OPA : coverpoint drv_trans.OPA { bins opa = {[0:`DATA_WIDTH-1]};}
		OPB : coverpoint drv_trans.OPB { bins opb = {[0:`DATA_WIDTH-1]};}
		CIN : coverpoint drv_trans.CE { bins cin = {0,1};}
		INP_VALID : coverpoint drv_trans.INP_VALID {bins ip_valid[] = {2'b00, 2'b01, 2'b10, 2'b11};}
		CMD : coverpoint drv_trans.CMD { bins command[] = {[0:15]};}
		MODE : coverpoint drv_trans.MODE { bins mode[] = {0,1};}
		CE : coverpoint drv_trans.CE { bins ce[] = {0,1};}
	endgroup

	//constrctor 
	function new(mailbox #(alu_transaction)mbx_gd,mailbox #(alu_transaction)mbx_dr, virtual alu_if.DRV vif);
		this.mbx_gd = mbx_gd;
		this.mbx_dr = mbx_dr;
		this.vif = vif;
		//create object for covergroup
		drv_cg = new();
	endfunction

	//function to check if cmd needs 2 operands
	function bit needs_2_op(logic [3:0] CMD, logic MODE);
		if(MODE == 1)begin
			return (CMD inside {4'd0,4'd1,4'd2,4'd3,4'd8,4'd9,4'd10});
		end else begin
			return (CMD inside {4'd0,4'd1,4'd2,4'd3,4'd4,4'd5,4'd12,4'd13});
		end
	endfunction

	//task to drive stimuli to interface
	task start();
		int c = 0;
		repeat(3)@(vif.drv_cb);

		for(int i = 0; i < `NO_OF_TRANS; i++) begin
			drv_trans = new();
			mbx_gd.get(drv_trans);

			if(vif.rst == 1) begin //check this
				vif.drv_cb.CE        <= drv_trans.CE;
				vif.drv_cb.MODE      <= drv_trans.MODE;
        vif.drv_cb.CMD       <= drv_trans.CMD;
        vif.drv_cb.CIN       <= drv_trans.CIN;
        vif.drv_cb.OPA       <= drv_trans.OPA;
        vif.drv_cb.OPB       <= drv_trans.OPB;
        vif.drv_cb.INP_VALID <= drv_trans.INP_VALID;

				//int c = 0;

				if(needs_2_op(drv_trans.CMD, drv_trans.MODE) && drv_trans.INP_VALID != 2'b11) begin
					//wait up to 16 cycles 
					while (vif.INP_VALID != 2'b11 && c < 16) begin
						@(vif.drv_cb);
						c++;

						//checking mailbox for updated inputs
						if (mbx_gd.num()>0) begin
							alu_transaction upd_trans;
							mbx_gd.get(upd_trans);

							//drives updated latest values into DUT
							vif.drv_cb.OPA <= upd_trans.OPA;
							vif.drv_cb.OPB <= upd_trans.OPB;
							
							//update in transaction local copy
							drv_trans.OPA = upd_trans.OPA;
							drv_trans.OPB = upd_trans.OPB;

							//update inp_valid to 11
							vif.drv_cb.INP_VALID <= 2'b11;
							drv_trans.INP_VALID = 2'b11;
						end
					end
				end

				@(vif.drv_cb); //ALU to latch inputs

				//send to reference model
				mbx_dr.put(drv_trans);
				drv_cg.sample();

				$display("[%0t] ---------- ALU DRIVER----------\n",$time);
				$display("CE=%0d, MODE=%0d, INP_VALID=%0d, CMD=%0d, OPA=%0d, OPB=%0d, CIN=%0d", drv_trans.CE, 
					         drv_trans.MODE, drv_trans.INP_VALID, drv_trans.CMD,drv_trans.OPA, drv_trans.OPB, drv_trans.CIN);
				
			end else begin
        // During reset
        vif.drv_cb.CE        <= 0;
        vif.drv_cb.OPA       <= 0;
        vif.drv_cb.OPB       <= 0;
        vif.drv_cb.INP_VALID <= 0;
        vif.drv_cb.CMD       <= 0;
        vif.drv_cb.CIN       <= 0;
        vif.drv_cb.MODE      <= 0;
        $display("[%0t] ALU DRIVER: DUT is in reset", $time);
      end

      @(vif.drv_cb);
    end

    $display("ALU DRIVER: Input Coverage = %0.2f%%", drv_cg.get_coverage());
  endtask
endclass
//`include "defines.sv"
//`include "alu_transaction.sv"

class alu_monitor;
	alu_transaction mon_trans;
	mailbox #(alu_transaction) mbx_ms; //monitor to scoreboard
	//virtual interface with monitor modport and its instance
	virtual alu_if.MON vif;

	//Functional coverage for outputs
	covergroup mon_cg;
		ERR: coverpoint mon_trans.ERR {bins err = {0,1};}
		OFLOW: coverpoint mon_trans.OFLOW {bins oflow = {0,1};}
		COUT: coverpoint mon_trans.COUT {bins cout = {0,1};}
		G: coverpoint mon_trans.G {bins g = {0,1};}
		L: coverpoint mon_trans.L {bins l = {0,1};}
		E: coverpoint mon_trans.E {bins e = {0,1};}
		RES: coverpoint mon_trans.RES {bins res = {[0:(`DATA_WIDTH-1)]};}
	endgroup

	//constructor
	function new(virtual alu_if.MON vif, mailbox #(alu_transaction)mbx_ms);
		this.vif = vif;
		this.mbx_ms = mbx_ms;

		//object for covergroup
		mon_cg = new();
	endfunction

	//check if cmd requires 2 or 1 operand
	function bit needs_2_op(logic [3:0] CMD, logic MODE);
		if(MODE == 1)begin
			return (CMD inside {4'd0, 4'd1, 4'd2, 4'd3, 4'd8, 4'd9, 4'd10});
		end else begin
			return (CMD inside {4'd0, 4'd1, 4'd2, 4'd3, 4'd4, 4'd5, 4'd12, 4'd13});
		end
	endfunction

	//delay based on commands
	function int get_output_delay(logic [3:0] CMD,logic MODE);
		if(CMD inside {4'd9,4'd10} && MODE == 1)
			return 3;
		else
			return 1;
	endfunction

	//task to collect output from interface
	task start();
		int delay, count;
		repeat(2) @(vif.mon_cb);

		for(int i = 0; i < `NO_OF_TRANS; i++ )begin

			//wait for 2nd inp if needed
			if (needs_2_op(vif.mon_cb.CMD, vif.mon_cb.MODE) && vif.mon_cb.INP_VALID != 2'b11) begin
				while (vif.mon_cb.INP_VALID != 2'b11 && count < 16) begin
					@(vif.mon_cb);
					count++;
				end
			end

			delay = get_output_delay(vif.mon_cb.CMD,vif.mon_cb.MODE);
			repeat(delay) @(vif.mon_cb); //wait 1 or 3 cycles based on cmd for output to become valid 

			mon_trans = new();

      // Capture inputs
      mon_trans.CE        = vif.mon_cb.CE;
      mon_trans.INP_VALID = vif.mon_cb.INP_VALID;
      mon_trans.MODE      = vif.mon_cb.MODE;
      mon_trans.CMD       = vif.mon_cb.CMD;
      mon_trans.OPA       = vif.mon_cb.OPA;
      mon_trans.OPB       = vif.mon_cb.OPB;
      mon_trans.CIN       = vif.mon_cb.CIN;

			//Capture outputs 
			mon_trans.RES   = vif.mon_cb.RES;
			mon_trans.COUT  = vif.mon_cb.COUT;
			mon_trans.OFLOW = vif.mon_cb.OFLOW;
			mon_trans.ERR   = vif.mon_cb.ERR;
			mon_trans.G     = vif.mon_cb.G;
			mon_trans.L     = vif.mon_cb.L;
			mon_trans.E     = vif.mon_cb.E;

			//send to scoreboard
			mbx_ms.put(mon_trans);
			mon_cg.sample();
			@(250);

			$display("[%0t] ---------- ALU MONITOR ----------\n",$time);
			$display("Input signals\n");
			$display("CE = %0d, IP_VALID = %0d, MODE = %0d, CMD = %0d, OPA = %0d, OPB = %0d, CIN = %0d",mon_trans.CE,
											  mon_trans.INP_VALID,mon_trans.MODE,mon_trans.CMD,mon_trans.OPA,mon_trans.OPB,mon_trans.CIN);
			$display("Output signals\n");
			$display("RES = %0d, COUT = %b, OFLOW = %b, ERR = %b, G = %b, L = %b, E = %b\n",mon_trans.RES, 
												mon_trans.COUT, mon_trans.OFLOW,mon_trans.ERR, mon_trans.G, mon_trans.L, mon_trans.E);

			$display("MONITOR: Output functional coverage = %0.2f%%", mon_cg.get_coverage());
			repeat(1)@(vif.mon_cb);
		end
		$display("********************** MONITOR COMPLETED *************************\n");
	endtask
endclass
//`include "alu_transaction.sv"

class alu_scb;
	//alu transaction class handles
	alu_transaction ref2sb_trans,mon2sb_trans;
	mailbox #(alu_transaction) mbx_rs; //ref_mod to scb mailbox
	mailbox #(alu_transaction) mbx_ms; //monitor to scb mailbox

	//associative arrays used for storing data_out (from ref_model, expected result) wrt address in ref model memory and storing data_out (from DUV, actual result) wrt address in monitor memory
	alu_transaction ref_mem [bit[`NO_OF_TRANS:0]];
	alu_transaction mon_mem [bit[`NO_OF_TRANS:0]];

	int MATCH,MISMATCH;

	//constructor to make mailbox connections
	function new(mailbox #(alu_transaction) mbx_rs, mailbox #(alu_transaction) mbx_ms);
		this.mbx_rs = mbx_rs;
		this.mbx_ms = mbx_ms;
	endfunction

	//task to collect data out from ref model and store in mem
	task start();
		$display("time = %0t\n ----------------------- SCOREBOARD ---------------------------\n",$time);
		for(int i = 0; i < `NO_OF_TRANS; i++)
			begin
				ref2sb_trans = new();
				mon2sb_trans = new();

				//getting trans from mailbox
				mbx_rs.get(ref2sb_trans);
				mbx_ms.get(mon2sb_trans);

				//store each transaction using index i
				ref_mem[i] = ref2sb_trans;
				mon_mem[i] = mon2sb_trans;

				//prints output
				 $display("### REF[%0d] => RES=%0h, CMD=%0d, OPA=%0d, OPB=%0d\n",
					               i, ref2sb_trans.RES, ref2sb_trans.CMD, ref2sb_trans.OPA, ref2sb_trans.OPB);

				 $display("### MON[%0d] => RES=%0h, CMD=%0d, OPA=%0d, OPB=%0d\n",
							              i, mon2sb_trans.RES, mon2sb_trans.CMD, mon2sb_trans.OPA, mon2sb_trans.OPB);
				compare_results(i);
			end
	endtask
  
	task compare_results(input int index);
  	if (ref_mem.exists(index) && mon_mem.exists(index)) begin
    	if (ref_mem[index].RES === mon_mem[index].RES) begin
      	$display("PASS: Transaction[%0d] RES match => %0h\n", index, ref_mem[index].RES);
      	MATCH++;
    	end else begin
      	$display("FAIL: Transaction[%0d] RES mismatch => REF=%0h, MON=%0h\n",
               index, ref_mem[index].RES, mon_mem[index].RES);
      	MISMATCH++;
    	end
  	end else begin
    $display("MISSING: Transaction[%0d] not found in memory\n", index);
  end
endtask

endclass
//`include "defines.sv"
//`include "alu_transaction.sv"

class alu_reference_model;
  //PROPERTIES
  alu_transaction ref_trans;
  mailbox #(alu_transaction) mbx_rs;
  mailbox #(alu_transaction) mbx_dr;
  virtual alu_if.REF_SB vif;

  //METHODS

  //Constructor
  function new(mailbox #(alu_transaction) mbx_dr,
               mailbox #(alu_transaction) mbx_rs,
               virtual alu_if.REF_SB vif);
    this.mbx_dr = mbx_dr;
    this.mbx_rs = mbx_rs;
    this.vif = vif;
  endfunction

  //Start task
  task start();
    for (int i = 0; i < `NO_OF_TRANS; i++) begin
      ref_trans = new();
      mbx_dr.get(ref_trans);

      if (op_wait_req(ref_trans.CMD, ref_trans.MODE, ref_trans.INP_VALID)) begin
        handle_op_wait();
      end else begin
        repeat (1) @(vif.ref_cb) begin
          calculate_expected_results(
            vif.rst,
            ref_trans.CE,
            ref_trans.MODE,
            ref_trans.CIN,
            ref_trans.INP_VALID,
            ref_trans.CMD,
            ref_trans.OPA,
            ref_trans.OPB,
            ref_trans.RES,
            ref_trans.COUT,
            ref_trans.E,
            ref_trans.G,
            ref_trans.L,
            ref_trans.OFLOW,
            ref_trans.ERR
          );

          $display("[REF MODEL] Time=%0t: RST=%0b CE=%0b MODE=%0b INP_VALID=%0b CMD=%0d",
                   $time, vif.rst, ref_trans.CE, ref_trans.MODE, ref_trans.INP_VALID, ref_trans.CMD);
          $display("[REF MODEL] OPA=%0h OPB=%0h CIN=%0b", ref_trans.OPA, ref_trans.OPB, ref_trans.CIN);
          $display("[REF MODEL] Expected: RES=%0h COUT=%0b EGL=%0b OFLOW=%0b ERR=%0b",
                   ref_trans.RES, ref_trans.COUT, {ref_trans.E, ref_trans.G, ref_trans.L},
                   ref_trans.OFLOW, ref_trans.ERR);
        end
      end

      mbx_rs.put(ref_trans);
    end
  endtask

  function bit op_wait_req(input [3:0] cmd, input mode, input [1:0] inp_valid);
    bit req_both_op = 0;
    if (mode) begin
      case (cmd)
        `ADD, `SUB, `ADD_CIN, `SUB_CIN, `CMP, `MULT, `SH1_MULT: req_both_op = 1;
        default: req_both_op = 0;
      endcase
    end else begin
      case (cmd)
        `AND, `NAND, `OR, `NOR, `XOR, `XNOR, `ROL_A_B, `ROR_A_B: req_both_op = 1;
        default: req_both_op = 0;
      endcase
    end
    return (req_both_op && (inp_valid == 2'b01 || inp_valid == 2'b10));
  endfunction

  task handle_op_wait();
    int timeout_counter = 0;
    bit op_received = 0;

    $display("[REF MODEL] Time=%0t: Waiting for missing operand, current inp_valid=%0b", $time, ref_trans.INP_VALID);

    for (timeout_counter = 0; timeout_counter < 16; timeout_counter++) begin
      @(vif.ref_cb);
      if (vif.INP_VALID == 2'b11) begin
        op_received = 1;
        ref_trans.INP_VALID = 2'b11;
        ref_trans.OPA = vif.ref_cb.OPA;
        ref_trans.OPB = vif.ref_cb.OPB;
        $display("[REF MODEL] Time=%0t: Missing operand received at cycle %0d", $time, timeout_counter + 1);
        break;
      end
    end

    if (op_received) begin
      calculate_expected_results(
        vif.rst,
        ref_trans.CE,
        ref_trans.MODE,
        ref_trans.CIN,
        ref_trans.INP_VALID,
        ref_trans.CMD,
        ref_trans.OPA,
        ref_trans.OPB,
        ref_trans.RES,
        ref_trans.COUT,
        ref_trans.E,
        ref_trans.G,
        ref_trans.L,
        ref_trans.OFLOW,
        ref_trans.ERR
      );
      $display("[REF MODEL] Time=%0t: Operation completed with both operands", $time);
    end else begin
      ref_trans.RES = 0;
      ref_trans.COUT = 0;
      {ref_trans.E, ref_trans.G, ref_trans.L} = 3'b000;
      ref_trans.OFLOW = 0;
      ref_trans.ERR = 1;
      $display("[REF MODEL] Time=%0t: Timeout after 16 cycles - setting error", $time);
    end

    $display("[REF MODEL] Final: RES=%0h COUT=%0b EGL=%0b OFLOW=%0b ERR=%0b",
             ref_trans.RES, ref_trans.COUT, {ref_trans.E, ref_trans.G, ref_trans.L},
             ref_trans.OFLOW, ref_trans.ERR);
  endtask

  task calculate_expected_results;
    input rst, ce, mode, cin;
    input [1:0] ip_v;
    input [3:0] cmd;
    input [`DATA_WIDTH-1:0] opa, opb;
    output reg [2*`DATA_WIDTH:0] expected_res;
    output reg expected_cout;
    output reg expected_e;
    output reg expected_g;
    output reg expected_l;
    output reg expected_overflow;
    output reg expected_error;

    integer rot_amt;

    begin
      expected_res = 0;
      expected_cout = 0;
      {expected_e, expected_g, expected_l} = 3'b000;
      expected_overflow = 0;
      expected_error = 0;

      if (rst) begin
        expected_res = 0;
        expected_cout = 0;
        {expected_e, expected_g, expected_l} = 3'b000;
        expected_overflow = 0;
        expected_error = 0;
      end else if (ce) begin
        rot_amt = opb[$clog2(`DATA_WIDTH)-1:0];

        case (ip_v)
          2'b00: expected_error = 1;

          2'b01: begin
            if (mode) begin
              case (cmd)
                `INC_A: begin expected_res = opa + 1; expected_error = (opa == {`DATA_WIDTH{1'b1}}); end
                `DEC_A: begin expected_res = opa - 1; expected_error = (opa == {`DATA_WIDTH{1'b0}}); end
                default: expected_error = 1;
              endcase
            end else begin
              case (cmd)
                `NOT_A: expected_res = {{`DATA_WIDTH{1'b0}}, ~opa};
                `SHR1_A: expected_res = {{`DATA_WIDTH{1'b0}}, opa >> 1};
                `SHL1_A: expected_res = {{`DATA_WIDTH{1'b0}}, opa << 1};
                default: expected_error = 1;
              endcase
            end
          end

          2'b10: begin
            if (mode) begin
              case (cmd)
                `INC_B: begin expected_res = opb + 1; expected_error = (opb == {`DATA_WIDTH{1'b1}}); end
                `DEC_B: begin expected_res = opb - 1; expected_error = (opb == {`DATA_WIDTH{1'b0}}); end
                default: expected_error = 1;
              endcase
            end else begin
              case (cmd)
                `NOT_B: expected_res = {{`DATA_WIDTH{1'b0}}, ~opb};
                `SHR1_B: expected_res = {{`DATA_WIDTH{1'b0}}, opb >> 1};
                `SHL1_B: expected_res = {{`DATA_WIDTH{1'b0}}, opb << 1};
                default: expected_error = 1;
              endcase
            end
          end

          2'b11: begin
            if (mode) begin
              case (cmd)
                `ADD: begin expected_res = opa + opb; expected_cout = expected_res[`DATA_WIDTH]; end
                `SUB: begin expected_res = opa - opb; expected_overflow = (opa < opb); end
                `ADD_CIN: begin expected_res = opa + opb + cin; expected_cout = expected_res[`DATA_WIDTH]; end
                `SUB_CIN: begin expected_res = opa - opb - cin; expected_overflow = (opa < (opb + cin)); end
                `INC_A: begin expected_res = opa + 1; expected_error = (opa == {`DATA_WIDTH{1'b1}}); end
                `DEC_A: begin expected_res = opa - 1; expected_error = (opa == {`DATA_WIDTH{1'b0}}); end
                `INC_B: begin expected_res = opb + 1; expected_error = (opb == {`DATA_WIDTH{1'b1}}); end
                `DEC_B: begin expected_res = opb - 1; expected_error = (opb == {`DATA_WIDTH{1'b0}}); end
                `CMP: begin
                  if (opa == opb) {expected_e, expected_g, expected_l} = 3'b100;
                  else if (opa > opb) {expected_e, expected_g, expected_l} = 3'b010;
                  else {expected_e, expected_g, expected_l} = 3'b001;
                end
                `MULT: expected_res = (opa + 1) * (opb + 1);
                `SH1_MULT: expected_res = (opa << 1) * opb;
                default: expected_error = 1;
              endcase
            end else begin
              case (cmd)
                `AND: expected_res = {{`DATA_WIDTH{1'b0}}, opa & opb};
                `NAND: expected_res = {{`DATA_WIDTH{1'b0}}, ~(opa & opb)};
                `OR: expected_res = {{`DATA_WIDTH{1'b0}}, opa | opb};
                `NOR: expected_res = {{`DATA_WIDTH{1'b0}}, ~(opa | opb)};
                `XOR: expected_res = {{`DATA_WIDTH{1'b0}}, opa ^ opb};
                `XNOR: expected_res = {{`DATA_WIDTH{1'b0}}, ~(opa ^ opb)};
                `NOT_A: expected_res = {{`DATA_WIDTH{1'b0}}, ~opa};
                `NOT_B: expected_res = {{`DATA_WIDTH{1'b0}}, ~opb};
                `SHR1_A: expected_res = {{`DATA_WIDTH{1'b0}}, opa >> 1};
                `SHR1_B: expected_res = {{`DATA_WIDTH{1'b0}}, opb >> 1};
                `SHL1_A: expected_res = {{`DATA_WIDTH{1'b0}}, opa << 1};
                `SHL1_B: expected_res = {{`DATA_WIDTH{1'b0}}, opb << 1};
                `ROL_A_B: begin
                  expected_error = |opb[`DATA_WIDTH-1:$clog2(`DATA_WIDTH)];
                  expected_res = {{`DATA_WIDTH{1'b0}}, (rot_amt == 0) ? opa : (opa << rot_amt) | (opa >> (`DATA_WIDTH - rot_amt))};
                end
                `ROR_A_B: begin
                  expected_error = |opb[`DATA_WIDTH-1:$clog2(`DATA_WIDTH)];
                  expected_res = {{`DATA_WIDTH{1'b0}}, (rot_amt == 0) ? opa : (opa >> rot_amt) | (opa << (`DATA_WIDTH - rot_amt))};
                end
                default: expected_error = 1;
              endcase
            end
          end

          default: expected_error = 1;
        endcase
      end else begin
        expected_error = 1;
      end
    end
  endtask

endclass
//`include "alu_environment.sv"

class alu_test;
//PROPERTIES
  //Virtual interfaces for driver, monitor and reference model
  virtual alu_if drv_vif;
  virtual alu_if mon_vif;
  virtual alu_if ref_vif;
  //Declaring handle for environment
  alu_environment env;

//METHODS
  //constructor to connect the virtual interfaces from driver, monitor and reference model to test
  function new(virtual alu_if drv_vif,
               virtual alu_if mon_vif,
               virtual alu_if ref_vif);
    this.drv_vif = drv_vif;
    this.mon_vif = mon_vif;
    this.ref_vif = ref_vif;
  endfunction

  //Task which builds the object for environment handle and calls the build and start methods of the environment
  task run();
    env = new(drv_vif,mon_vif,ref_vif);
    env.build;
    env.start;
  endtask
endclass
/*`include "defines.sv"
`include "alu_transaction.sv"
`include "alu_reference_model.sv"
`include "alu_scb.sv"
`include "alu_generator.sv"
`include "alu_driver.sv"
`include "alu_monitor.sv"
*/
class alu_environment;
	//virtual interfaces for dirver, monitor and ref model
	virtual alu_if drv_vif;
	virtual alu_if mon_vif;
	virtual alu_if ref_vif;

	//mailboxes
	mailbox #(alu_transaction) mbx_gd; //gen to drv
	mailbox #(alu_transaction) mbx_dr; //drv to ref
	mailbox #(alu_transaction) mbx_rs; //ref to scb
	mailbox #(alu_transaction) mbx_ms; //mon to scb

	//declaring handles for components
	alu_generator        gen;
	alu_driver           drv;
	alu_monitor          mon;
	alu_reference_model  r_m;
	alu_scb              scb;

	//new constructor to connect virtual interfaces from drv, mon, ref to test
	function new (virtual alu_if drv_vif,
								virtual alu_if mon_vif,
			          virtual alu_if ref_vif);
		this.drv_vif=drv_vif;
		this.mon_vif=mon_vif;
		this.ref_vif=ref_vif;
	endfunction

	//task to create objects for mailboxes and components
	task build();
		begin
			mbx_gd = new();
			mbx_dr = new();
			mbx_rs = new();
			mbx_ms = new();

			gen = new(mbx_gd);
			drv = new(mbx_gd,mbx_dr,drv_vif);
			mon = new(mon_vif,mbx_ms);
			r_m = new(mbx_dr,mbx_rs,ref_vif);
			scb = new(mbx_rs,mbx_ms);
		end
	endtask

	//task to call the start method of each components
	task start();
		fork
			gen.start();
			drv.start();
			mon.start();
			scb.start();
			r_m.start();
		join
		//scb.compare_results();
	endtask

endclass
//`include "alu_pkg.sv"

`include "defines.sv"
`include "alu_interface.sv"
`include "alu_design.sv"
`include "alu_transaction.sv"
`include "alu_generator.sv"
`include "alu_driver.sv"
`include "alu_monitor.sv"
`include "alu_reference_model.sv"
`include "alu_scb.sv"
`include "alu_environment.sv"
`include "alu_test.sv"


module top();

  // Import all classes/types from package
  //import alu_pkg::*;

  // Clock and Reset
  bit clk;
  bit rst;

  // Clock Generation
  initial clk = 0;
  always #5 clk = ~clk;

  // Reset Sequence
  initial begin
    rst = 0;
    @(posedge clk);
    repeat (2) @(posedge clk);
    rst = 1;
  end

  // Interface instantiation
  alu_if intf(clk, rst);

  // ALU Design Under Verification (DUV)
  ALU_DESIGN DUV (
    .OPA(intf.OPA),
    .OPB(intf.OPB),
		.INP_VALID(intf.INP_VALID),
		.CE(intf.CE),
		.MODE(intf.MODE),
		.CIN(intf.CIN),
    .CMD(intf.CMD),
    .RES(intf.RES),
    .COUT(intf.COUT),
    .OFLOW(intf.OFLOW),
		.G(intf.G),
		.E(intf.E),
		.L(intf.L),
		.ERR(intf.ERR),
    .CLK(clk),
    .RST(rst)
  );

  // Test class instantiation
  alu_test test = new(intf.DRV, intf.MON, intf.REF_SB);

  // Start test
  initial begin
    test.run();
    $finish;
  end

endmodule

//`include "defines.sv"

class alu_transaction;
	//input signals
	rand bit [`DATA_WIDTH-1:0] OPA,OPB;
	rand bit [1:0] INP_VALID;
	randc bit [3:0] CMD;
	rand bit CE,CIN,MODE;

	//output signals
	bit [2*`DATA_WIDTH:0] RES;
  bit ERR,OFLOW,COUT,G,L,E;

	constraint ip_valid{INP_VALID dist {2'b00 := 1, 2'b10 := 2, 2'b01 := 2, 2'b11 := 5 };}
	constraint command{CMD inside {[0:15]};} //to cover invalid cmd range also
	constraint ce{ CE dist {0 := 2, 1 := 10};}
	constraint cin_needed { if (!(CMD inside {4'b0010, 4'b0011}) || MODE == 0) CIN == 0;} //cin is active only for add and sub in arithmetic op
	
		//METHODS
		//copying objects for blueprint
		virtual function alu_transaction copy();
			copy = new();
			copy.OPA = this.OPA;
			copy.OPB = this.OPB;
			copy.INP_VALID = this.INP_VALID;
			copy.CMD = this.CMD;
			copy.CE = this.CE;
			copy.CIN = this.CIN;
			copy.MODE = this.MODE;
			return copy;
		endfunction
endclass
// This package includes all the files in the ALU testbench architecture
// which will be imported in the top module

package alu_pkg;
	`include "defines.sv"
  `include "alu_transaction.sv"
  `include "alu_generator.sv"
  `include "alu_driver.sv"
  `include "alu_monitor.sv"
  `include "alu_reference_model.sv"
  `include "alu_scb.sv"
  `include "alu_environment.sv"
  `include "alu_test.sv"

endpackage

`timescale 1ns/100ps

`ifndef DEFINES_V
`define DEFINES_V

`define DATA_WIDTH 8
`define CMD_WIDTH 4
`define NO_OF_TRANS 5

//arithmetic commands
`define ADD      4'd0
`define SUB      4'd1
`define ADD_CIN  4'd2
`define SUB_CIN  4'd3
`define INC_A    4'd4
`define DEC_A    4'd5
`define INC_B    4'd6
`define DEC_B    4'd7
`define CMP      4'd8
`define MULT     4'd9
`define SH1_MULT 4'd10

//logical commands
`define AND      4'd0
`define NAND     4'd1
`define OR       4'd2
`define NOR      4'd3
`define XOR      4'd4
`define XNOR     4'd5
`define NOT_A    4'd6
`define NOT_B    4'd7
`define SHR1_A   4'd8
`define SHR1_B   4'd9
`define SHL1_A   4'd10
`define SHL1_B   4'd11
`define ROL_A_B  4'd12
`define ROR_A_B  4'd13

`endif
